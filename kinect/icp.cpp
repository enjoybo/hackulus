//
//  icp.cpp
//  Use ICP to register a set of 3D point clouds.
//
//  Created by Jonathan Lee on 11/30/14.
//  Copyright (c) 2014 Jonathan Lee. All rights reserved.
//

#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
#include <vector>
#include <utility>
#include <queue>
#include <cmath>
#include <time.h>
#include <cstdlib>

#include "icp.hpp"

/**
 * Applies a rotation and transformation matrix to a point cloud.
 *
 * p should be a nx6 which represents the point cloud each row is a single point: (x, y, z, b, g, r)
 */
Mat applyTransformation(const Mat &p, const Mat &r, const Mat &t) {
  Mat c = p.colRange(0, 3);
  Mat c_ = r * c.t();
  for (int i = 0; i < 3; ++i) {
    for (int j = 0; j < c_.row(i).cols; ++j) {
      c_.row(i).col(j) += t.at<float>(i);
    }
  }
  c_ = c_.t();
  Mat p_ = p.clone();
  for (int i = 0; i < p_.rows; ++i) {
    for (int j = 0; j < 3; ++j) {
      p_.at<float>(i, j) = c_.at<float>(i, j);
    }
  }
  return p_;
}

/**
 * Takes a matrix a and b, which are both mx3 matrices
 * the cooresponding rows in each matrix represent the matching
 * pairs.
 *
 * "Returns" the 3x3 rotation matrix and the 3x1 translation vector
 * to transform a onto b
 */
void rigid_transform_3D(const Mat &a, const Mat &b, Mat &r, Mat &t) {
  int n = a.rows;

  // Find the centroids
  Mat centroid_a = Mat::zeros(1, 3, CV_32F);
  Mat centroid_b = Mat::zeros(1, 3, CV_32F);
  for (int i = 0; i < n; ++i) {
    centroid_a.row(0) += a.row(i);
    centroid_b.row(0) += b.row(i);
  }
  centroid_a /= n;
  centroid_b /= n;

  // Center the points
  Mat aa = a.clone();
  Mat bb = b.clone();
  for (int i = 0; i < n; ++i) {
    aa.row(i) -= centroid_a;
    bb.row(i) -= centroid_b;
  }

  // Compute the SVD
  Mat u, w, vt;
  SVD::compute(aa.t() * bb, w, u, vt);

  // Find the rotation and translation matrices from the SVD results
  r = vt.t() * u.t();
  if (determinant(r) < 0) {
    r.row(2) *= -1;
  }

  t = -r * centroid_a.t() + centroid_b.t();
}

/**
 * Takes a matrix pc_a and pc_b which are both nx6 matrices
 * where the number of rows represents the number of
 * point clouds and the cols represent the (x, y, z, b, g, r)
 * of each point
 *
 * "Returns" matrices a and b, which are both mx3 matrices
 * the zip of the two matrices represents the (x, y, z) of the
 * points that match
 */
void nearest_neighbors(const Mat &pc_a, const Mat &pc_b, Mat &a, Mat &b) {
  flann::Index kdtree(pc_a.colRange(0, 3).clone(), flann::KDTreeIndexParams(1));
  a = Mat::zeros(pc_b.rows, 3, CV_32F);
  b = pc_b.colRange(0, 3).clone();
  Mat indices = Mat::zeros(1, 1, CV_32F);
  Mat dists = Mat::zeros(1, 1, CV_32F);

  for (int i = 0; i < b.rows; ++i) {
    //        std::cout << b.row(i) << std::endl;
    kdtree.knnSearch(b.row(i), indices, dists, 1, flann::SearchParams(16));

    int index = indices.at<int>(0);
    pc_a.row(index).colRange(0, 3).copyTo(a.row(i));
  }
}

/**
 * Load a single kinect frame generated by the kinect.py script
 * as a point cloud (an Nx6 matrix, where N is the number of
 * points and each row contains (x, y, z, b, g, r)).
 */
Mat load_kinect_frame(const string image_filename, const string depth_filename) {
  Mat image, pc;
  int dim_row, dim_col;

  image = imread(image_filename);
  if (!image.data) {
    std::cout << "Could not read '" << image_filename << "'\n";
    throw Exception();
  }
  dim_row = image.rows;
  dim_col = image.cols;
  image = image.reshape(3, image.rows * image.cols);

  std::ifstream file(depth_filename);
  pc = Mat::zeros(1, 6, CV_32F);
  pc.pop_back(1);
  string line;


  for (int i = 0; getline(file, line); ++i) {
    std::istringstream in(line);
    float x, y, z, b, g, r;
    in >> z;
    if (z > 0) {
      x = i / dim_col;
      y = i % dim_col;
      b = image.at<Vec3b>(i, 0)[0];
      g = image.at<Vec3b>(i, 0)[1];
      r = image.at<Vec3b>(i, 0)[2];
      Mat p = (Mat_<float>(1, 6) << x, y, z, b, g, r);
      pc.push_back(p);
    }
  }
  return pc;
}

/**
 * Saves a point cloud as a PLY file.
 */
void save_point_cloud(Mat &a, string filename) {
  std::fstream plyFile;

  plyFile.open(filename, std::fstream::out);
  plyFile << "ply" << std::endl;
  plyFile << "format ascii 1.0" << std::endl;
  plyFile << "element vertex " << a.rows << std::endl;
  plyFile << "property float x" << std::endl;
  plyFile << "property float y" << std::endl;
  plyFile << "property float z" << std::endl;
  plyFile << "property uchar blue" << std::endl;
  plyFile << "property uchar green" << std::endl;
  plyFile << "property uchar red" << std::endl;
  plyFile << "end_header" << std::endl;

  for (int i = 0; i < a.rows; ++i) {
    for (int j = 0; j < 3; ++j) {
      plyFile << a.at<float>(i, j) << " ";
    }
    for (int j = 3; j < 5; ++j) {
      plyFile << (int) round(a.at<float>(i, j)) << " ";
    }
    plyFile << (int) round(a.at<float>(i, 5)) << "\n";
  }

  plyFile.close();
}

/**
 * Extracts the rotation and translation matrix from a rigid transformation
 * matrix.
 *
 * Used for extracting the transformation matrices from the accumulated rigid
 * transform.
 */
void extractRigidTransform(const Mat& m, Mat& rotation, Mat& translation) {
  rotation = Mat::zeros(3, 3, CV_32F);
  translation = Mat::zeros(3, 1, CV_32F);

  for (int i = 0; i < 3; ++i) {
    for (int j = 0; j < 3; ++j) {
      rotation.at<float>(i, j) = m.at<float>(i, j);
    }
  }

  translation.at<float>(0, 0) = m.at<float>(0, 3);
  translation.at<float>(0, 1) = m.at<float>(1, 3);
  translation.at<float>(0, 2) = m.at<float>(2, 3);
}

/**
 * Combines a rotation and translation matrix into a single
 * rigid transformation matrix.
 *
 * Used for creating a single matrix that can be used to accumulating the
 * transformation matrices.
 */
Mat getRigidTransform(const Mat& rotation, const Mat& translation) {
  Mat m = Mat::eye(4, 4, CV_32F);

  for (int i = 0; i < 3; ++i) {
    for (int j = 0; j < 3; ++j) {
      m.at<float>(i, j) = rotation.at<float>(i, j);
    }
  }

  m.at<float>(0, 3) = translation.at<float>(0, 0);
  m.at<float>(1, 3) = translation.at<float>(0, 1);
  m.at<float>(2, 3) = translation.at<float>(0, 2);

  return m;
}

/**
 * Select a random sample of the points in pts.
 *
 * A random number is generated for each point and if the number
 * is lower than PROBABILITY, the point is included in the subsample.
 */
Mat selectRandomPoints(const Mat& pts, double probability) {
  std::vector<Mat> points;

  for (int i = 0; i < pts.rows; ++i) {
    double uniform = (rand() / ((double) RAND_MAX));

    if (uniform <= probability) {
      points.push_back(pts.row(i).clone());
    }
  }

  Mat sample = Mat::zeros((int) points.size(), pts.cols, CV_32F);
  for (int i = 0; i < points.size(); ++i) {
    points[i].copyTo(sample.row(i));
  }

  return sample;
}
